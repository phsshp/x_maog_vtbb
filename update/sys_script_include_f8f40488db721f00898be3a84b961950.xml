<?xml version="1.0" encoding="UTF-8"?>
<record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_maog_vtbb.BoardBuilderGroup</api_name>
        <client_callable>false</client_callable>
        <description>Optimizes queries to manage groups of boards</description>
        <name>BoardBuilderGroup</name>
        <script><![CDATA[var BoardBuilderGroup = Class.create();
BoardBuilderGroup.prototype = (function BoardBuilderGroup_proto(s) {
	var p = {};
	var TYPE = p.type = 'BoardBuilderGroup';
	var TABLE = 'x_maog_vtbb_board_builder_group';

	RecordWrapper.setup(p, TABLE, 'BBG');

	var log = s.log = x_spar2_log.Logger.getLogger(TYPE, gs.getCurrentScopeName());
	var call = Function.prototype.call;

	p.initialize = function initialize(sysIdOrGr) {
		this.set(sysIdOrGr);
	};

	p.getBoardBuilder = function getBoardBuilder() {
		if (!this.boardBuilder) {
			var bbSysId = this.getGr().getValue('board_builder');
			this.boardBuilder = new BoardBuilder(bbSysId);
		}
		return this.boardBuilder;
	};

	p.getGroup = function getGroup() {
		if (!this.group) {
			var groupSysId = this.getGr().getValue('group');
			this.group = new Group(groupSysId);
		}
		return this.group;
	};

	// Return array of Groups matching a list of Board Builders,
	// based on the current Board Builder Groups related list.
	s.findGroupsForBoardBuilder = function findGroupsForBoardBuilder(bb) {
		var gr, groups = [];

		gr = new GlideRecord(TABLE);
		gr.addQuery('board_builder', 'IN', bb.getSysId());
		gr.query();
		while (gr.next()) {
			groups.push(new BoardBuilderGroup(gr.getUniqueValue()));
		}
		return groups;
	};

	// Add a new link between a board builder and a group.
	s.addRecord = function addRecord(bbSysId, groupSysId) {
		var bbg;
		var gr = new GlideRecord(TABLE);
		gr.initialize();
		gr.setValue('board_builder', bbSysId);
		gr.setValue('group', groupSysId);
		log.debug('inserting board builder group {0} {1}', bbSysId, groupSysId);
		gr.insert();
		bbg = new BoardBuilderGroup(gr);
		if (log.isDebugging()) log.debug('{0} inserted record', bbg.toString());
		return bbg;
	};

	// Run a query and return an array of board builder groups that match.
	s.query = function(filter) {
		var bbgs = [];
		var gr = new GlideRecord(TABLE);
		if (typeof filter === 'function') {
			filter.call(this, gr);
		} else {
			addEncodedQuery(filter);
		}
		gr.query();
		while (gr.next()) {
			bbgs.push(new BoardBuilderGroup(gr.getUniqueValue()));
		}
		return bbgs;
	};

	// Do not reference the GlideRecord parameter because it is a cursor.
	// Save the SysID and get a new GlideRecord if required.
	p.initialize = function initialize(grOrSysId) {
		this.set(grOrSysId);
	};

	p.deleteRecord = function deleteRecord() {
		log.debug('{0} deleting record', this + '');
		this.getGr().deleteRecord();
	};

	// Find the users affected by this board builder and group.
	// This is a superset of users that already have the board.
	p.getApplicableUsers = function getApplicableUsers() {
		var users;
		
		var bb = this.getBoardBuilder();
		var group = this.getGroup();

		// Find the group's users the builder applies to
		users = User.query(function(gr) {
			gr.addQuery('user', 'IN', group.getUserSysIds());
			gr.addEncodedQuery(bb.getUserFilter());
		});
		users = users.filter(function(u) {
			var applies = u.hasRoleSysIds(bb.getUserRoleSysIds());
			return applies;
		});
		return users;
	};

	// Find VTBs that reference this board and group.
	p.getReferencingVtbs = function getReferencingVtbs(userSysIds) {
		var gr, vtbs = [];
		var mySysId = this.getSysId();

		gr = new GlideRecord('vtb_board');
		gr.addQuery('x_maog_vtbb_builder', mySysId);
		gr.addQuery('user', 'IN', userSysIds);

		gr.query();

		while (gr.next()) {
			vtbs.push(gr);
		}
		// TODO: Clean up - above or below?
		filter = 'board_builder=' + mySysId + '^';
		filter = 'userIN' + userSysIds + '^EQ';
		users = Users.queryUsers(filter);
		return users;
	};

	// When a record is added, run the board builder
	// for the group's applicable users.
	p.added = function added() {
		var bb, group, allUsers, usersWithBoard, newBoards;

		if (log.isDebugging()) log.debug('{0} business rule for insert', this + '');

		bb = this.getBoardBuilder();
		group = this.getGroup();

		allUsers = bb.getApplicableUsers(group);
		usersWithBoard = bb.getUsersWithBoard(allUsers.join(','));

		// Add boards for the remaining users.
		newBoards = Utils.subtractArraysHashed(allUsers, usersWithBoard, function(user) {
			return user.getSysId();
		});
		Utils.a_forEach(newBoard, function(user) {
			bb.addBoardForUser(user);
		});

		// TODO: Delete boards for users who left the group.
	};

	p.removed = function removed() {
		if (log.isDebugging()) log.debug('{0} business rule for delete', this + '');
	};

	return p;
})(BoardBuilderGroup);  // End BoardBuilderGroup_proto]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>peter.smith</sys_created_by>
        <sys_created_on>2018-06-14 15:39:17</sys_created_on>
        <sys_id>f8f40488db721f00898be3a84b961950</sys_id>
        <sys_mod_count>75</sys_mod_count>
        <sys_name>BoardBuilderGroup</sys_name>
        <sys_package display_value="Visual Task Board Builder" source="x_maog_vtbb">ae48259bdbee9b00898be3a84b9619f7</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Visual Task Board Builder">ae48259bdbee9b00898be3a84b9619f7</sys_scope>
        <sys_update_name>sys_script_include_f8f40488db721f00898be3a84b961950</sys_update_name>
        <sys_updated_by>peter.smith</sys_updated_by>
        <sys_updated_on>2018-06-24 22:29:03</sys_updated_on>
    </sys_script_include>
</record_update>
