<?xml version="1.0" encoding="UTF-8"?>
<record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_maog_vtbb.BoardBuilder</api_name>
        <client_callable>false</client_callable>
        <description/>
        <name>BoardBuilder</name>
        <script><![CDATA[var BoardBuilder = Class.create();
BoardBuilder.prototype = (function BoardBuilder_proto(s) {
	var p = {};
	var TYPE = p.type = 'BoardBuilder';
	var TABLE = s.TABLE = 'x_maog_vtbb_board_builder';

	// Some activities are similar for ownership and membership.
	// Support reuse with these constants.
	var BB = s.BB = p.BB = {};
	BB.OWNERS = 'owner';
	BB.MEMBERS = 'member';

	var log = s.log = x_spar2_log.Logger.getLogger(TYPE, gs.getCurrentScopeName());

	var o_forOwnProperties = Utils.o_forOwnProperties;

	var rw = RecordWrapper.setup(p, s, TABLE, 'BB');

	p.initialize = function initialize(grOrSysId, share) {
		rw.set(grOrSysId, share, this);
	};  // End initialize

	p.getState = function getState() { return this.getGr().getValue('state'); };

	p.isActive = function isActive() {
		var gr = this.getGr();
		var answer = Utils.getGlideTrueFalse(gr, 'active');
		return answer;
	};

	// Set active flag based on current state.
	//
	// Called by BR "Board Builder Active Flag"
	//
	p.setActive = function setActive() { // 1
		var myGr = this.getGr();
		var state = myGr.getValue('state');
		var active = (state === 'Operational') ? true : false;
		myGr.setValue('active', active);
		if (log.isDebugging()) log.debug(
			'{0} set active to {1} for State={2}',
			this + '', active, myGr.getDisplayValue('state'));
		return active;
	};

	// Add members to a VTB associated with this BoardBuilder.
	//
	// Invoked as part of VTB creation.
	//
	// Precondition: Given this BoardBuilder, a group satisfying
	//  the postconditions for SynchBbgs, and a
	//  VTB corresponding to a user meeting this BoardBuilder's
	//  conditions for board ownership,
	// Postcondition: There exists exactly one VtbMember record
	//  that satisfies this BoardBuilder and Group's membership
	//  conditions.
	//
	p.synchVtbMembers = function synchVtbMembers(vtb, group) {
		var bb, bbGr, members, filter, once;

		bb = this;
		bbGr = bb.getGr();

		bb.forNewEligibleMembers(vtb, group, function addMember(memberSysId) {
			VtbMember.createRecord(function setFields(memberGr) {
				memberGr.setValue('board', vtb.getSysId());
				memberGr.setValue('user', memberSysId);
			});
		});
	};

	// Add lanes to a VTB this Board Builder is building.
	// Precondition: Given this BoardBuilder, a group satisfying
	//  the postconditions for synchBoardBuilderGroups, and a
	//  VTB corresponding to a user meeting this BoardBuilder's
	//  conditions for board ownership,
	// Postcondition: There exists exactly one VtbLane record
	//  for each value (specified by Task Table and Lane Field)
	//  that satisfies this BoardBuilder's Lane Conditions.
	//
	p.synchVtbLanes = function synchVtbLanes(vtb, group, owner) {
		VtbLane.synchLanes(this, vtb, group, owner);
	};

	p.setVtbFilter = function setVtbFilter(vtb, group, owner) {
		var bb, bbGr, vtbGr, buffer, ownerSysIds = [], filter, query;

		bb = this;
		bbGr = bb.getGr();
		vtbGr = vtb.getGr();
		buffer = [];

		if (bbGr.getValue('task_assigned_to') === 'board_members') {
			// Spell this out in case some group members are not board members.
			buffer.push('assigned_toISEMPTY');
			bb.forNewEligibleMembers(vtb, group, function addSysId(memberSysId) {
				log.debug('setVtbFilter.addSysId({0})', memberSysId);
				buffer.push('^ORassigned_to=');
				buffer.push(memberSysId);
			});
		} else if (bbGr.getValue('task_assigned_to') === 'group_members') {
			buffer.push('assignment_group=');
			buffer.push(group.getSysId());
		}
		filter = bbGr.getValue('board_filter');
		if (filter) {
			buffer.push('^');
			buffer.push(filter);
		}

		query = buffer.join('');
		if (log.isDebugging()) {
			log.debug('{0} setVtbFilter({1}, {2}, {3})={4}', 
					  [bb.toString(), vtb.toString(), group.toString(),
					   owner.toString(), query]);
		}

		vtbGr.setValue('filter', query);
	};

	// Initialize a VtbBoard record based on this Board Builder.
	//
	// Preconditions: Given this BoardBuilder, a group satisfying
	//  the postconditions for SynchBbgs, and a
	//  VTB corresponding to a user meeting this BoardBuilder's
	//  conditions for board ownership,
	// Postconditions: The VTB's values are initialized from
	//  this BoardBuilder's configuration values including the
	//  template and the owner.
	//  
	p.setVtbValues = function setVtbValues(vtb, group, owner) { // 1
		var bb, bbGr, bbSysId, vtbGr, templateSysId, templateGr, name, filter;

		bb = this;
		bbGr = bb.getGr();
		vtbGr = vtb.getGr();

		templateSysId = bbGr.getValue('template');
		templateGr = GlideTemplate.get(templateSysId);
		templateGr.apply(vtbGr);

		name = vtbGr.getValue('name');
		if (name.match(/{\d+}/)) {
			name = gs.getMessage(name, group.getDisplayValue());
		}
		vtbGr.setValue('name', name);

		vtbGr.setValue('x_maog_vtbb_builder', bb.getSysId());
		// vtbGr.setValue('x_maog_vtbb_template', bbGr.getValue('template'));

		vtbGr.setValue('owner', owner.getSysId());
		vtbGr.setValue('assignment_group', group.getSysId());
		vtbGr.setValue('table', bbGr.getValue('table'));
		vtbGr.setValue('field', bbGr.getValue('field'));
	};

	// Set the query to find a VTB corresponding to a builder/user/group.
	p.setOwnedBoardQuery = function setOwnedBoardQuery(vtbGr, group, owner, filter) {
		vtbGr.addQuery('x_maog_vtbb_builder', this.getSysId());
		vtbGr.addQuery('assignment_group', group.getSysId());
		vtbGr.addQuery('owner', owner.getSysId());
		if (filter) vtbGr.addEncodedQuery(filter);
	};

	// Create a VTB record unconditionally.
	p.createVtbRecord = function createVtbRecord(group, owner, vtb) {
		var bb = this;
		if (!vtb) {
			vtb = VtbBoard.initRecord(function builder(vtbGr, vtb) {
				bb.setVtbValues(vtb, group, owner);
				bb.setVtbFilter(vtb, group, owner);
			});
		}
		vtb.insert();
		this.synchVtbMembers(vtb, group, owner);
		this.synchVtbLanes(vtb, group, owner);
	};

	// TODO: Owner Filter
	// Given this Board Builder, a group, and an owner, make sure
	// the owner has a copy of this Board Builder's task board.
	p.synchVtbRecord = function synchVtbRecord(group, owner) { // 1
		var members, bb, vtbs, vtb, filter, vtbGr, eligible;
		bb = this;

		// Create the vtb if it meets this builder's criteria
		vtb = VtbBoard.initRecord(function initVtb(vtbGr, vtb) {
			bb.setVtbValues(vtb, group, owner);
			bb.setVtbFilter(vtb, group, owner);
		});
		vtbGr = new GlideRecord('vtb_board');
		vtbGr.initialize();
		filter = bb.getValue(bb.getGr().getValue('owner_user_filter'));
		bb.setOwnedBoardQuery(vtbGr, group, owner, filter);
		filter = vtbGr.getEncodedQuery();
		if (!filter || GlideFilter.checkRecord(vtbGr, filter)) {
			this.createVtbRecord(group, owner, vtb);
			return vtb;
		}
	};

	// Apply a function once for each member of the supplied group that does
	// not already own this VTB.
	p.forNewEligibleOwners = function forNewEligibleOwners(group, addFn) {
		var bb, requiredRoleSysIds, groupUserSysIds, users, once;

		bb = this;
		requiredRoleSysIds = bb.getGr().getValue('owner_roles');
		once = new Once();

		// Find all the users in this group.
		groupUserSysIds = [];
		if (bb.getGr().getValue('owner_group_members') === 'Include') {
			GroupMember.query(function filter(memberGr) {
				memberGr.addQuery('group', group.getSysId());
			}, function builder(memberGr) {
				groupUserSysIds.push(memberGr.getValue('user'));
			});
		}
		if (bb.getGr().getValue('owner_group_manager') === 'Include') {
			mgr = group.getManager();
			if (mgr) {
				groupUserSysIds.push(mgr.getSysId());
			}
		}

		// Narrow based on the board builder filter conditions.
		users = User.query(function filter(userGr) {
			userGr.addQuery('sys_id', 'IN', groupUserSysIds.join(','));
			userGr.addEncodedQuery(bb.getGr().getValue('owner_user_filter'));
			groupUserSysIds = [];
		}, function builder(userGr) {
			var user = new User(userGr.getUniqueValue());
			if (user.hasRoleSysIds(requiredRoleSysIds)) {
				groupUserSysIds.push(user.getSysId());
				return user;
			}
		});

		// Find existing VTBs.
		VtbBoard.query(function filter(vtbGr) {
			vtbGr.addQuery('x_maog_vtbb_builder', bb.getSysId());
			vtbGr.addQuery('owner', 'IN', groupUserSysIds);
		}, function builder(vtbGr) {
			once.exists(vtbGr.getUniqueValue(), vtb.getKey());
		});

		// Create new VTBs.
		users.forEach(function tryToAddUser(user) {
			log.debug('forNewEligibleOwners.tryToAddUser({0})', user.toString());
			once.add(user, user.getSysId(), function addUser() {
				log.debug('forNewEligibleOwners.tryToAddUser.addUser {0})', user.toString());
				addFn(user);
			});
		});
	};

	// Apply a function once for each member of the supplied group that does
	// not already own this VTB.
	p.forNewEligibleMembers = function forNewEligibleMembers(vtb, group, addFn) {
		var bb, requiredRoleSysIds, groupUserSysIds, mgr, members, once;

		bb = this;
		requiredRoleSysIds = bb.getGr().getValue('member_roles');
		once = new Once();

		// Find the desired members in this group.
		groupUserSysIds = [];
		if (bb.getGr().getValue('member_group_members') === 'Include') {
			GroupMember.query(function filter(memberGr) {
				memberGr.addQuery('group', group.getSysId());
			}, function builder(memberGr) {
				groupUserSysIds.push(memberGr.getValue('user'));
			});
		}
		if (bb.getGr().getValue('member_group_manager') === 'Include') {
			mgr = group.getManager();
			if (mgr) {
				groupUserSysIds.push(mgr.getSysId());
			}
		}

		// Narrow based on member filter conditions.
		members = User.query(function filter(userGr) {
			userGr.addQuery('sys_id', 'IN', groupUserSysIds.join(','));
			userGr.addEncodedQuery(bb.getGr().getValue('member_user_filter'));
			groupUserSysIds = [];
		}, function addMember(memberGr) {
			var member = new User(memberGr.getUniqueValue());
			if (member.hasRoleSysIds(requiredRoleSysIds)) {
				groupUserSysIds.push(member.getSysId());
				return member;
			}
		});

		// Find existing board memberss.
		VtbMember.query(function filter(vtbGr) {
			vtbGr.addQuery('board', vtb.getSysId());
		}, function builder(grMemberGr) {
			var grMember = new VtbMember(grMemberGr);
			var memberSysId = grMember.getValue('user');
			var member = new User(memberSysId);
			once.exists(member, member.getSysId);
		});

		// Create new board members.
		groupUserSysIds.forEach(function tryToAddUser(memberSysId) {
			log.debug('forNewEligibleMembers.tryToAddUser({0})', memberSysId);
			once.add('x', memberSysId, function addUser() {
				log.debug('forNewEligibleMembers.tryToAddUser.addUser {0})', memberSysId);
				addFn(memberSysId);
			});
		});
	};

	p.getGroupTypes = function getGroupTypes(type) { // 1
		type = type || BB.OWNERS;
		var groupTypesStr = this.getGr().getValue(type + '_group_types');
		var groupTypesSort = groupTypesStr.split(',').sort();
		return groupTypesSort;
	};

	// The group must have all the group types in this Board
	// Builder's Group Types field.  It also must match the
	// group filter.
	p.setGroupQueryString =  function setGroupQueryString(gr, type) { // 1
		var bbGroupTypes, bbGroupTypesLen, groupQuery;
		type = type || BB.OWNERS;

		bbGroupTypes = this.getGroupTypes(type);
		bbGroupTypesLen = bbGroupTypes.length;
		for (var bbti = 0; bbti < bbGroupTypesLen; bbti++) {
			gr.addQuery('type', 'LIKE', bbGroupTypes[bbti]);
		}

		groupQuery = this.getGr().getValue(type + '_group_filter');
		gr.addEncodedQuery(groupQuery);
	};

	// Update BoardBuilderGroups to match this BoardBuilder.
	//
	// Called indirectly by BR "Board Builder Updated"
	//
	// Note that a BoardBuilderGroup record is NEVER updated.
	// They are created or deleted and otherwise remain constant.
	// Modifying one's reference is not a valid test.
	//
	// Precondition:   Given one BoardBuilder
	// Postcondition:  For this board and every Group
	//  that satisfies the BoardBuilder's ownership conditions
	//  there exists exactly one BoardBuilderGroup record
	//  associating the BoardBuilder and the Group.
	//
	p.SynchBbgs = function SynchBbgs() { // 1
		var bb = this;
		var bbSysId = bb.getSysId();
		var groupMap = {};
		var deleteIds = [];
		var EXISTS = 1, MATCHED = 2;
		var once = new Once();

		if (log.isDebugging()) {
			log.debug('{0} SynchBbgs()', this.toString());
		}

		// Get existing builder groups that reference this board builder.
		// Add their Sys IDs to the bbgGroupMap.
		function bbgKey(bbgSysId) { return bbSysId + '.' + bbgSysId; }
		BoardBuilderGroup.query(function filter(gr) {
			gr.addQuery('board_builder', bbSysId);
		}, function rebuildBbg(bbgGr) {
			new BoardBuilderGroup(bbGr).update();
			once.exists(bbg, bbgKey(bbgGr.group));
		});

		// Synch every Group that satisfies this Board Builder's
		// Group conditions.
		Group.query(function filter(groupGr) {
			bb.setGroupQueryString(groupGr, BB.OWNERS);
		}, function process(groupGr) {
			once.add(groupGr, bbgKey(groupGr.getUniqueValue), function tryGroup(groupGr) {
				var group = new Group(groupGr);
				BoardBuilderGroup.createRecord(bb, group);
			});
		});

		// Remove groups that are no longer eligible.
		once.removeRemaining(function removeBbg(bbgGr) {
			deleteIds.push(bbgGr.getUniqueValue());
		});
		if (deleteIds.length > 0) {
			Group.deleteMultiple(function filter(gr) {
				gr.addQuery('sys_id', 'IN', deleteIds.join(','));
			});
		}
	};


	// This BoardBuilder was updated in such a way that its owner
	// groups may have changed.  Invoked when BR "Board Builder
	// Updated" detects a change with potential impact on owner group
	// membership in this BoardBuilder.
	//
	p.updated = function updated() {
		var rebuild;

		// TODO: Decide whether we should rebuild when the builder
		// configuration changes.  Currently we never rebuild.
		// To rebuild, the administrator must delete VTBs and their
		// parent BoardBuilderGroup.

		if (log.isDebugging()) log.debug('{0} record updated', this.toString());
		this.SynchBbgs(rebuild);
	};

	return p;
})(BoardBuilder);  // End BoardBuilder_proto]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>peter.smith</sys_created_by>
        <sys_created_on>2018-06-12 18:31:44</sys_created_on>
        <sys_id>f6195ad3db62db00898be3a84b961938</sys_id>
        <sys_mod_count>295</sys_mod_count>
        <sys_name>BoardBuilder</sys_name>
        <sys_package display_value="Visual Task Board Builder" source="x_maog_vtbb">ae48259bdbee9b00898be3a84b9619f7</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Visual Task Board Builder">ae48259bdbee9b00898be3a84b9619f7</sys_scope>
        <sys_update_name>sys_script_include_f6195ad3db62db00898be3a84b961938</sys_update_name>
        <sys_updated_by>peter.smith</sys_updated_by>
        <sys_updated_on>2018-07-20 13:10:06</sys_updated_on>
    </sys_script_include>
</record_update>
