<?xml version="1.0" encoding="UTF-8"?>
<record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_maog_vtbb.VtbLane</api_name>
        <client_callable>false</client_callable>
        <description>Manages a VTB Lane's type information.</description>
        <name>VtbLane</name>
        <script><![CDATA[var VtbLane = Class.create();
VtbLane.prototype = (function VtbLane_proto(s) {
	var p = {};
	var TYPE = p.type = 'VtbLane';
	var TABLE = 'vtb_lane';

	var log = s.log = x_spar2_log.Logger.getLogger(TYPE, gs.getCurrentScopeName());

	var rw = RecordWrapper.setup(p, s, TABLE, 'VTL', log);

	var slice = Function.prototype.apply.bind(Array.prototype.slice);
	var Dsc = Once.Descriptor;

	var UNASSIGNED = '';
	function isUnassigned(value) { return value === null || value === ''; }

	p.initialize = function initialize(grOrSysId, share) {
		rw.set(grOrSysId, share, this);
	}; // End initialize

	s.synch = function	synch(bb, vtb, group, owner) {
		var laneOnce, highOrder;

		highOrder = 0;
		laneOnce = new Once('laneOnce');

		// Find existing Lanes.
		function findExistingLanes() {
			VtbLane.query(
				function filterLane(vtlGr) {
					vtlGr.addQuery('board', vtb.getSysId());
				},
				function checkLane(vtlGr) {
					var order, key, label, dsc;
					order = vtlGr.getValue('order');
					highOrder = Math.max(highOrder, order);
					label = vtlGr.getValue('name');
					key = vtlGr.getValue('value');
					dsc = new Dsc(key, label, order);
					dsc.vtlId = vtlGr.getUniqueValue();
					laneOnce.exists(dsc, key);
					log.debug('{0} Found lane [lane:{1} key:{2} label:{3}]',
							  vtb + '', dsc.vtlId + '', key + '', label);
				}
			);
		}

		function synchVtbLane(dsc, key, state) {
			var vtl, vtlId, vtbId, label, updating;

			label = dsc.obj;
			vtbId = vtb.getSysId();
			vtlId = dsc.vtlId;

			updating = (state === Once.STATE.EXISTS);
			if (!updating && state !== Once.STATE.ADDED
				|| updating && !bb.updateExisting()) {
				log.debug('Skipping [Lane {0} {1}]', key, label);
				return;
			}

			if (updating) {
				vtlGr = new GlideRecord(TABLE);
				if (vtlGr.get(vtlId)) {
					vtlGr.setValue('board', vtbId);
					vtlGr.setValue('value', key);
					vtlGr.setValue('name', label);
					vtlGr.setValue('order', ++highOrder);

					vtl = new VtbLane(vtlGr, rw.MODE.SHARED);
					log.debug('updated {0}', vtl + '');

					vtlGr.update();
				} else {
					log.warn('Could not find lane {0} {1} {2}',
							 vtlId, key, label);
				}
			} else {
				vtl = new VtbLane();
				vtlGr = vtl.getGr();
				vtlGr.setValue('board', vtbId);
				vtlGr.setValue('value', key);
				vtlGr.setValue('name', label);
				vtlGr.setValue('order', ++highOrder);
				log.info('adding {0}', vtl + '');
				vtlGr.update();
			}
		}

		// TODO: Finish
		function forEachChoice(taskGr, taskGe, TaskGed) {
			var fieldName, label, values;

			fieldName = bb.getLaneField();

			values.forEach(function choiceValue(value) {
				var bd = new BoardDescription(

				);
				taskGr.setValue(fieldName, value);
				label = taskGr[fieldName].getChoiceValue();
				laneOnce.add(value, label);
			});
		}

		// TODO: Finish
		function forEachReference() {
			var value, label, taskGa, fieldName;

			fieldName = bb.getLaneField();

			taskGa = new GlideAggregate(bb.getTaskTable());
			taskGa.addAggregate('COUNT', fieldName);
			taskGa.addEncodedQuery(vtb.getValue('board_filter'));
			taskGa.orderBy(fieldName);
			taskGa.groupBy(fieldName);
			taskGa.query();
			while (taskGa.next()) {
				value = taskGa.getValue(fieldName);
				laneOnce.exists(new Dsc(
					value,
					taskGa[fieldName].getDisplayValue()
				), value);
			}
		}

		// Set visibility after lanes are created below
		function setUserLaneVisibility() {
			var showUnassigned, showManager, showOwner, showMembers, showUser;

			showUnassigned = bb.isUnassignedVisible();
			showManager = bb.isManagerVisible();
			showOwner = bb.isOwnerVisible();	
			showMembers = bb.areMembersVisible();
			showUser = bb.isUserVisible();	

			// Iterate to create a preference for each user with a lane.
			laneOnce.forEach(
				function setPref(outerDsc, outerKey, outerState) {
					var prefName, prefGr, hide, updateId, userId, updating;

					userId = outerKey;
					if (!userId) {
						return;
					}

					// Find lanes to hide for this user.
					hide = [];
					laneOnce.forEach(
						function hideLanes(innerDsc, innerKey, innertState) {
							var show = showMembers && innerDsc.member ||
								showUser && innerDsc.member && innerKey === userId ||
								showUnassigned && innerDsc.unassigned ||
								showManager && innerDsc.manager ||
								showOwner && innerDsc.owner;
							if (!show) {
								hide.push(innerDsc.vtlId);
							}
						}
					);

					if (hide.length > 0) {
						prefName = 'vtb.board.' + vtb.getSysId() + '.hiddenLanes';
						prefGr = new GlideRecord('sys_user_preference');
						prefGr.addQuery('name', prefName);
						prefGr.addQuery('user', userId);
						prefGr.query();
						updating = prefGr.next();
						if (!updating) {
							prefGr.initialize();
							prefGr.setNewGuidValue(gs.generateGUID());
						}
						prefGr.setValue('description', 'Generated for ' + vtb.getDisplayValue());
						prefGr.setValue('name', prefName);
						prefGr.setValue('type', 'string');
						prefGr.setValue('user', outerKey);
						hide = hide.join('-');
						prefGr.setValue('value', hide);
						prefGr.setValue('system', false);

						if (updating) {
							log.debug('updating user preference {0} {1} {2}={3}',
									  prefGr.getUniqueValue(), outerDsc.obj, prefName, hide);
						} else {
							log.info('adding user preference {0} {1} {2}={3}',
									 prefGr.getUniqueValue(), outerDsc.obj, prefName, hide);
						}
						prefGr.update();
					}
				}
			);
		}

		function createUserContent() {
			var mgr, dsc;

			// Create User Lanes
			if (bb.showUnassignedLane()) {
				dsc = new Dsc(UNASSIGNED, bb.getUnassignedLaneLabel());
				laneOnce.update(
					dsc, UNASSIGNED,
					function memberLane(oldDsc, key, state) {
						synchVtbLane(oldDsc, key, state);
						oldDsc.unassigned = true;
					}
				);
			}

			if (bb.showManagerLane()) {
				mgr = group.getManager();
				if (mgr) {
					dsc = new Dsc(mgr.getSysId(), mgr.getDisplayValue());
					laneOnce.update(
						dsc, mgr.getSysId(),
						function memberLane(oldDsc, key, state) {
							synchVtbLane(oldDsc, key, state);
							oldDsc.owner = true;
						}
					);
				}
			}

			if (bb.showOwnerLane()) {
				dsc = new Dsc(owner.getSysId(), owner.getDisplayValue());
				laneOnce.update(
					dsc, owner.getSysId(),
					function memberLane(oldDsc, key, state) {
						synchVtbLane(oldDsc, key, state);
						oldDsc.owner = true;
					}
				);
			}

			// For every board member, create a lane if member lanes
			// were requested.  Collect information we need in the
			// boards array.
			if (bb.showMemberLanes()) {
				VtbMember.query(
					function vtbMemberFilter(vtmGr) {
						vtmGr.query('board', vtb.getSysId());
					}, 
					function vtbMemberActions(vtmGr) {
						var userId = vtmGr.getValue('user');
						var userName = vtmGr.user.getDisplayValue();
						dsc = new Dsc(userId, userName);
						laneOnce.update(
							dsc, userId,
							function memberLane(oldDsc, key, state) {
								synchVtbLane(oldDsc, key, state);
								oldDsc.member = true;
							}
						);
					}
				);
			}
			setUserLaneVisibility();
		}

		function manageReference(taskGe) {
			var refTable = taskGe.getReferenceTable();
			switch (refTable) {
				case 'sys_user':
					createUserContent();
					break;
					//	case 'sys_user_group':
					//		forEachGroup(fn);
					// 		break;
				default:
					forEachReference();
			}
		}

		function addLanes() {
			var taskGr, taskGe, TaskGed, laneType, values;

			taskGr = new GlideRecord(bb.getTaskTable());
			taskGr.initialize();
			taskGe = taskGr[bb.getLaneField()];
			values = taskGe.getChoices();
			TaskGed = taskGe.getED();

			laneType = TaskGed.getInternalType();
			if (TaskGed.isChoiceTable()) {
				forEachChoice(taskGr, taskGe, TaskGed);
			} else {
				switch (laneType) {
					case 'reference':
						manageReference(taskGe);
						break;
					default:
						new TypeError('Unknown lane type: ' + laneType);
				}
			}
		}

		findExistingLanes();
		addLanes();
	};

	s.query = rw.query;

	return p;
})(VtbLane);  // End VtbLane_proto]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>peter.smith</sys_created_by>
        <sys_created_on>2018-07-07 22:14:31</sys_created_on>
        <sys_id>f85ab317dbcb5380d4b15eea4b96194b</sys_id>
        <sys_mod_count>105</sys_mod_count>
        <sys_name>VtbLane</sys_name>
        <sys_package display_value="Visual Task Board Builder" source="x_maog_vtbb">ae48259bdbee9b00898be3a84b9619f7</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Visual Task Board Builder">ae48259bdbee9b00898be3a84b9619f7</sys_scope>
        <sys_update_name>sys_script_include_f85ab317dbcb5380d4b15eea4b96194b</sys_update_name>
        <sys_updated_by>peter.smith</sys_updated_by>
        <sys_updated_on>2018-08-07 00:04:12</sys_updated_on>
    </sys_script_include>
</record_update>
